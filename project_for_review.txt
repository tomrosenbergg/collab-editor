
================================================================================
FILE: tsconfig.node.json
================================================================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


================================================================================
FILE: index.html
================================================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>collab-editor</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


================================================================================
FILE: tsconfig.app.json
================================================================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


================================================================================
FILE: package.json
================================================================================

{
  "name": "collab-editor",
  "homepage": "https://tomrosenbergg.github.io/collab-editor",
  "private": true,
  "version": "0.0.0",
  "type": "module",
"scripts": {
  "dev": "vite",
  "build": "tsc && vite build",
  "lint": "eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
  "preview": "vite preview",
  "predeploy": "npm run build",
  "deploy": "gh-pages -d dist"
},
  "dependencies": {
    "@codemirror/lang-javascript": "^6.2.4",
    "@codemirror/state": "^6.5.4",
    "@codemirror/view": "^6.39.12",
    "@supabase/supabase-js": "^2.95.2",
    "codemirror": "^6.0.2",
    "lodash": "^4.17.23",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "y-codemirror.next": "^0.3.5",
    "y-protocols": "^1.0.7",
    "yjs": "^13.6.29"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "gh-pages": "^6.3.0",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}


================================================================================
FILE: tsconfig.json
================================================================================

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


================================================================================
FILE: eslint.config.js
================================================================================

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


================================================================================
FILE: vite.config.ts
================================================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig(({ command }) => {
  const config = {
    plugins: [react()],
    base: '/', // Default for local development
  }

  // Only use the sub-path for production builds (GitHub Pages)
  if (command !== 'serve') {
    config.base = '/collab-editor/'
  }

  return config
})

================================================================================
FILE: src/Auth.tsx
================================================================================

import { useState } from 'react'
import { SupabaseClient } from '@supabase/supabase-js'

interface Props {
  supabase: SupabaseClient
}

export const Auth = ({ supabase }: Props) => {
  const [loading, setLoading] = useState(false)
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [isLogin, setIsLogin] = useState(true)
  const [msg, setMsg] = useState('')

  const handleAuth = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)
    setMsg('')

    try {
      if (isLogin) {
        const { error } = await supabase.auth.signInWithPassword({ email, password })
        if (error) throw error
      } else {
        const { error } = await supabase.auth.signUp({ email, password })
        if (error) throw error
        setMsg('Check your email for the login link!')
      }
    } catch (error: any) {
      setMsg(error.message)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div style={{ 
      display: 'flex', flexDirection: 'column', alignItems: 'center', 
      justifyContent: 'center', height: '100vh', color: '#e0e0e0', fontFamily: 'sans-serif' 
    }}>
      <h1 style={{ fontFamily: 'Courier Prime, monospace' }}>Screenplay Editor</h1>
      <form onSubmit={handleAuth} style={{ display: 'flex', flexDirection: 'column', gap: '1rem', width: '300px' }}>
        <input
          type="email"
          placeholder="Email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          style={{ padding: '10px', background: '#333', border: 'none', color: 'white' }}
        />
        <input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          style={{ padding: '10px', background: '#333', border: 'none', color: 'white' }}
        />
        <button type="submit" disabled={loading} style={{ 
          padding: '10px', cursor: 'pointer', background: '#30bced', border: 'none', color: 'black', fontWeight: 'bold' 
        }}>
          {loading ? 'Processing...' : (isLogin ? 'Log In' : 'Sign Up')}
        </button>
      </form>
      <p style={{ marginTop: '1rem', cursor: 'pointer', textDecoration: 'underline', fontSize: '0.9rem' }} 
         onClick={() => setIsLogin(!isLogin)}>
        {isLogin ? "Need an account? Sign Up" : "Have an account? Log In"}
      </p>
      {msg && <p style={{ color: '#ffbc42', marginTop: '1rem' }}>{msg}</p>}
    </div>
  )
}

================================================================================
FILE: src/App.tsx
================================================================================

import { useState, useEffect } from 'react'
import { createClient, type Session } from '@supabase/supabase-js'
import { CollaborativeEditor } from './CollaborativeEditor'
import { Auth } from './Auth'
import { Dashboard } from './Dashboard'
import './App.css'

const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL,
  import.meta.env.VITE_SUPABASE_ANON_KEY,
  { realtime: { params: { eventsPerSecond: 10 } } }
)

function App() {
  const [session, setSession] = useState<Session | null>(null)
  const [currentDocId, setCurrentDocId] = useState<string | null>(null)
  const [showDashboard, setShowDashboard] = useState(false)

  useEffect(() => {
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session)
      if (session) setShowDashboard(true) // Show dashboard on login
    })

    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session)
      if (!session) {
        setCurrentDocId(null)
        setShowDashboard(false)
      } else {
        // If we just logged in and have no doc open, show dashboard
        if (!currentDocId) setShowDashboard(true)
      }
    })
    return () => subscription.unsubscribe()
  }, [currentDocId])

  // Context Menu Implementation (Minimalist)
  const Menu = () => (
    <div style={{ 
      position: 'fixed', top: 20, left: 20, zIndex: 50,
      display: 'flex', gap: '10px'
    }}>
      <button 
        onClick={() => setShowDashboard(true)}
        style={{ 
          background: '#333', color: 'white', border: 'none', padding: '8px 12px', 
          borderRadius: '4px', cursor: 'pointer', opacity: 0.7 
        }}
      >
        ≡ Files
      </button>
      {/* Add Rename or other menu items here if needed */}
    </div>
  )

  if (!session) {
    return <Auth supabase={supabase} />
  }

  return (
    <div className="App">
      {/* Minimal Context Menu */}
      <Menu />

      {/* Editor - Key forces remount when doc changes */}
      {currentDocId ? (
        <CollaborativeEditor 
          key={currentDocId} // CRITICAL: Forces editor to reset when ID changes
          documentId={currentDocId} 
          supabase={supabase} 
        />
      ) : (
        <div style={{ 
          height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#666' 
        }}>
          No document open
        </div>
      )}

      {/* Dashboard Modal */}
      {showDashboard && (
        <Dashboard 
          supabase={supabase}
          userId={session.user.id}
          onOpenDocument={(id) => {
            setCurrentDocId(id)
            setShowDashboard(false)
          }}
          onClose={() => {
            // Only allow closing if a document is already open, otherwise keep it open
            if (currentDocId) setShowDashboard(false)
          }}
        />
      )}
    </div>
  )
}

export default App

================================================================================
FILE: src/SupabaseProvider.ts
================================================================================

import * as Y from 'yjs'
import { RealtimeChannel, SupabaseClient } from '@supabase/supabase-js'
import { Awareness, encodeAwarenessUpdate, applyAwarenessUpdate } from 'y-protocols/awareness'

export class SupabaseProvider {
  doc: Y.Doc
  channel: RealtimeChannel
  awareness: Awareness
  private _isConnected: boolean = false
  private _resyncInterval: ReturnType<typeof setInterval> | null = null

  constructor(doc: Y.Doc, supabase: SupabaseClient, channelId: string) {
    this.doc = doc
    this.awareness = new Awareness(doc)
    this.channel = supabase.channel(channelId)

    this.channel
      // 1. Handle Awareness (Cursors/Presence)
      .on('broadcast', { event: 'awareness-update' }, ({ payload }) => {
        applyAwarenessUpdate(this.awareness, new Uint8Array(payload), 'remote')
      })
      
      // 2. Sync Step 1: Remote peer sent their State Vector
      // We calculate what they are missing and send ONLY that (Sync Step 2)
      .on('broadcast', { event: 'sync-step-1' }, ({ payload }) => {
        const remoteVector = new Uint8Array(payload)
        const update = Y.encodeStateAsUpdate(doc, remoteVector)
        // Only broadcast if there is actually a difference
        if (update.length > 0) {
            this.broadcast('sync-step-2', update)
        }
      })

      // 3. Sync Step 2: Remote peer sent an Update
      // We apply this update to our local document
      .on('broadcast', { event: 'sync-step-2' }, ({ payload }) => {
        const update = new Uint8Array(payload)
        Y.applyUpdate(doc, update, 'remote')
      })

      // 4. Connection Status
      .subscribe((status) => {
        if (status === 'SUBSCRIBED') {
          this._isConnected = true
          this.initSync()
        } else {
          this._isConnected = false
        }
      })

    // 5. Listen to Local Changes -> Broadcast Update (Step 2)
    doc.on('update', (update, origin) => {
      if (origin !== 'remote' && origin !== 'db-load' && this._isConnected) {
        // We broadcast the update directly to peers
        this.broadcast('sync-step-2', update)
      }
    })

    // 6. Listen to Local Awareness Changes
    this.awareness.on('update', ({ added, updated, removed }) => {
      if (!this._isConnected) return
      const changedClients = added.concat(updated).concat(removed)
      const update = encodeAwarenessUpdate(this.awareness, changedClients)
      this.broadcast('awareness-update', update)
    })

    // 7. Periodic Health Check / Soft Resync (Every 30s)
    this._resyncInterval = setInterval(() => {
      if (this._isConnected && this.awareness.getStates().size > 0) {
        this.initSync()
      }
    }, 30000)
  }

  // Initiates the sync protocol by sending our local State Vector
  private initSync() {
    // We send our State Vector (fingerprint) so peers know what we need
    const vector = Y.encodeStateVector(this.doc)
    this.broadcast('sync-step-1', vector)
  }

  private broadcast(event: string, payload: Uint8Array) {
    if (!this._isConnected) return
    this.channel.send({
      type: 'broadcast',
      event,
      payload: Array.from(payload),
    })
  }

  destroy() {
    if (this._resyncInterval) clearInterval(this._resyncInterval)
    this.channel.unsubscribe()
    this.awareness.destroy()
    // DOC LIFECYCLE: We do NOT destroy the doc here.
    // The doc is owned by the React Component state.
  }
}

================================================================================
FILE: src/main.tsx
================================================================================

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


================================================================================
FILE: src/Dashboard.tsx
================================================================================

import { useEffect, useState } from 'react'
import { SupabaseClient } from '@supabase/supabase-js'

interface Document {
  id: string
  title: string
  updated_at: string
}

interface Props {
  supabase: SupabaseClient
  userId: string
  onOpenDocument: (id: string) => void
  onClose: () => void
}

export const Dashboard = ({ supabase, userId, onOpenDocument, onClose }: Props) => {
  const [docs, setDocs] = useState<Document[]>([])
  const [loading, setLoading] = useState(true)
  const [newTitle, setNewTitle] = useState('')

  useEffect(() => {
    fetchDocs()
  }, [])

  const fetchDocs = async () => {
    const { data } = await supabase
      .from('documents')
      .select('id, title, updated_at')
      .order('updated_at', { ascending: false })
    if (data) setDocs(data)
    setLoading(false)
  }

  const createDoc = async () => {
    if (!newTitle.trim()) return
    const { data, error } = await supabase
      .from('documents')
      .insert({ title: newTitle, owner_id: userId, content: '' }) // Init empty
      .select()
      .single()
    
    if (data) {
      onOpenDocument(data.id)
    } else if (error) {
      console.error(error)
    }
  }

  const deleteDoc = async (id: string, e: React.MouseEvent) => {
    e.stopPropagation()
    if (!confirm('Are you sure you want to delete this screenplay?')) return
    await supabase.from('documents').delete().eq('id', id)
    fetchDocs()
  }

  return (
    <div style={{
      position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.85)', zIndex: 100,
      display: 'flex', justifyContent: 'center', alignItems: 'center'
    }}>
      <div style={{
        background: '#1a1a1a', border: '1px solid #444', padding: '2rem',
        width: '500px', maxHeight: '80vh', overflowY: 'auto', borderRadius: '8px'
      }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '2rem' }}>
          <h2 style={{ margin: 0 }}>My Screenplays</h2>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#666', cursor: 'pointer' }}>Close</button>
        </div>

        {/* Create New */}
        <div style={{ display: 'flex', gap: '10px', marginBottom: '2rem' }}>
          <input 
            value={newTitle}
            onChange={(e) => setNewTitle(e.target.value)}
            placeholder="New Screenplay Title..."
            style={{ flex: 1, padding: '8px', background: '#333', border: 'none', color: 'white' }}
          />
          <button onClick={createDoc} style={{ padding: '8px 16px', background: '#30bced', border: 'none', cursor: 'pointer' }}>
            Create
          </button>
        </div>

        {/* List */}
        {loading ? <p>Loading...</p> : (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
            {docs.map(doc => (
              <div 
                key={doc.id} 
                onClick={() => onOpenDocument(doc.id)}
                style={{
                  padding: '15px', background: '#222', border: '1px solid #333',
                  cursor: 'pointer', display: 'flex', justifyContent: 'space-between', alignItems: 'center'
                }}
                onMouseEnter={(e) => e.currentTarget.style.borderColor = '#555'}
                onMouseLeave={(e) => e.currentTarget.style.borderColor = '#333'}
              >
                <div>
                  <div style={{ fontWeight: 'bold' }}>{doc.title}</div>
                  <div style={{ fontSize: '0.8rem', color: '#666' }}>
                    {new Date(doc.updated_at).toLocaleDateString()}
                  </div>
                </div>
                <button 
                  onClick={(e) => deleteDoc(doc.id, e)}
                  style={{ color: '#ee6352', background: 'none', border: 'none', cursor: 'pointer', fontSize: '1.2rem' }}
                >
                  ×
                </button>
              </div>
            ))}
            {docs.length === 0 && <p style={{ color: '#666' }}>No scripts found.</p>}
          </div>
        )}
      </div>
    </div>
  )
}

================================================================================
FILE: src/App.css
================================================================================

/* src/App.css */

/* 1. Global Reset for Dark Mode */
:root {
  background-color: #1a1a1a; /* The nice dark grey */
  color: #e0e0e0;
}

body {
  margin: 0;
  padding: 0;
  background-color: #1a1a1a;
  overflow: hidden; /* Prevent body scroll, let CodeMirror handle it */
  width: 100vw;
  height: 100vh;
}

#root {
  width: 100%;
  height: 100%;
  padding: 0;
  margin: 0;
}

/* 2. Remove all component spacing */
.App {
  width: 100%;
  height: 100%;
}

/* 3. CodeMirror Specific Overrides */
.cm-editor {
  outline: none !important;
}

/* Ensure the scrollbar is unobtrusive (optional) */
::-webkit-scrollbar {
  width: 8px;
}
::-webkit-scrollbar-track {
  background: #1a1a1a; 
}
::-webkit-scrollbar-thumb {
  background: #333; 
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: #444; 
}

================================================================================
FILE: src/index.css
================================================================================

/* src/index.css */
:root {
  font-family: 'Courier Prime', 'Courier', monospace;
  font-size: 18px; /* Comfortable writing size */
  line-height: 1.5;
  font-weight: 400;

  color-scheme: dark; /* Tells browser to use dark defaults */
  
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}

================================================================================
FILE: src/CollaborativeEditor.tsx
================================================================================

import { useEffect, useRef, useState, useMemo } from 'react'
import * as Y from 'yjs'
import { EditorView, basicSetup } from 'codemirror'
import { EditorState } from '@codemirror/state'
import { yCollab } from 'y-codemirror.next'
import { SupabaseClient } from '@supabase/supabase-js'
import { SupabaseProvider } from './SupabaseProvider'
import { useYjsPersistence } from './hooks/useYjsPersistence'

const USER_COLORS = ['#30bced', '#6eeb83', '#ffbc42', '#ecd444', '#ee6352']

// ... (Theme code remains exactly the same as previous) ...
const darkScreenplayTheme = EditorView.theme({
  "&": { height: "100vh", backgroundColor: "transparent", color: "#e0e0e0" },
  ".cm-scroller": { overflow: "auto", fontFamily: "'Courier Prime', 'Courier', monospace" },
  ".cm-content": { 
    caretColor: "white", margin: "0 auto", maxWidth: "60ch", 
    paddingLeft: "2.5ch", paddingRight: "2.5ch", paddingTop: "50vh", paddingBottom: "50vh" 
  },
  ".cm-cursor": { borderLeftColor: "white", borderLeftWidth: "2px" },
  ".cm-gutters": { display: "none" },
  ".cm-activeLine": { backgroundColor: "transparent" },
  ".cm-activeLineGutter": { backgroundColor: "transparent" }
})

interface Props {
  documentId: string
  supabase: SupabaseClient
}

export const CollaborativeEditor = ({ documentId, supabase }: Props) => {
  const editorRef = useRef<HTMLDivElement>(null)
  
  // LIFECYCLE FIX:
  // We use useState to lazily create the Y.Doc once.
  // We DO NOT destroy it in useEffect cleanup to prevent strict mode crashes.
  // JS Garbage Collection will handle it when the component is truly discarded.
  const [doc] = useState(() => new Y.Doc())

  const { status, loadDocument, saveDocument } = useYjsPersistence(supabase, doc)

  useEffect(() => {
    // 1. Initialize Provider
    const provider = new SupabaseProvider(doc, supabase, documentId)
    const ytext = doc.getText('codemirror')

    // 2. Set Random User Info
    provider.awareness.setLocalStateField('user', {
      name: 'Writer ' + Math.floor(Math.random() * 100),
      color: USER_COLORS[Math.floor(Math.random() * USER_COLORS.length)],
    })

    // 3. Configure Editor
    const state = EditorState.create({
      doc: ytext.toString(), // Initial text (sync logic will update this shortly)
      extensions: [
        basicSetup,
        darkScreenplayTheme,
        yCollab(ytext, provider.awareness), // Bind Yjs to CodeMirror
        EditorView.lineWrapping,
        
        // Typewriter Scrolling
        EditorView.scrollMargins.of((view) => {
          const dom = view.dom;
          const halfHeight = dom.clientHeight / 2;
          return { top: halfHeight - 10, bottom: halfHeight - 10 };
        }),

        // Save Trigger
        EditorView.updateListener.of((update) => {
          if (update.docChanged) {
            saveDocument(documentId)
          }
        })
      ],
    })

    const view = new EditorView({
      state,
      parent: editorRef.current!,
    })

    // 4. Load initial state from DB
    loadDocument(documentId)

    // 5. Cleanup
    return () => {
      view.destroy()
      provider.destroy()
      // NOTE: We specifically do NOT destroy 'doc' here.
    }
  }, [documentId, supabase, doc, saveDocument, loadDocument])

  return (
    <>
      <div 
        ref={editorRef} 
        style={{ width: '100%', height: '100vh', outline: 'none' }} 
      />
      
      {/* Status Indicator */}
      <div style={{
        position: 'fixed', bottom: 20, right: 20,
        color: '#666', fontFamily: 'sans-serif', fontSize: '12px', pointerEvents: 'none'
      }}>
        {status === 'loading' && 'Loading...'}
        {status === 'saving' && 'Saving...'}
        {status === 'saved' && 'Saved'}
        {status === 'error' && 'Sync Error'}
      </div>
    </>
  )
}

================================================================================
FILE: src/parser/fountain.g
================================================================================

@precedence { p1 @left, p2 @left, p3 @left }


@top Screenplay { TitlePage? (Boneyard | Element)+ }

Element {
    ActionLine |
    ForcedActionLine |
    CenterLine |
    CharacterBlock |
    DualCharacterBlock |
    EmptyLine |
    ForceTransition |
    SceneHeadingLine |
    SectionLine |
    SynopsisLine |
    TransitionLine |
    PageBreakLine
}


// --- Boneyard ---

Boneyard { !p1 BoneStart Element* BoneEnd}


// --- Title Page Rules ---
// A title page contains one or more TitleKey:TitleValue pairs. The block ends with two newlines

TitlePage { (TitleKey TitleValue Newline)+ EmptyLine EmptyLine }



// --- Character & Dialogue Rules ---

CharacterBlock { 
   CharacterCue
   Newline
   (DialogueLine Newline | Parenthetical Newline)+
}

CharacterCue {
  Character
  ( WhiteSpace | LineParenthetical )* 
}

DualCharacterBlock {
  DualCharacterCue
  Newline
  (DialogueLine Newline | Parenthetical Newline)+
}

DualCharacterCue {
  DualCharacter
  (WhiteSpace | LineParenthetical)* 
}

Parenthetical { !p2 LParen Inline+ RParen }

DialogueLine { !p1 Inline+ }



// --- Other Rules ---

SceneHeadingLine { SceneHeading (Inline | LineParenthetical)* SceneNumber? Newline }

LineParenthetical { !p2 LParen Inline+ RParen } // stuff that's not in a dialogueblock

ActionLine { !p2 (LineParenthetical | Inline)+ Newline }

ForcedActionLine { !p2 ForceActionMark (LineParenthetical | Inline)+ Newline }

PageBreakLine { !p1 PageBreak Newline }

TransitionLine { !p1 Transition Newline }

SectionLine { !p2 SectionMark+ (LineParenthetical | Inline)* Newline}

SynopsisLine { !p1 SynopsisMark (LineParenthetical | Inline)+ Newline}

ForceTransition { ForceRight Newline }

ForceRight { GreaterThan (LineParenthetical | Inline)+ }

CenterLine { ForceRight LessThan Newline }

SceneNumber {SectionMark Numbers* SectionMark}


// --- Formatting Rules ---

ItalicBold { !p2 TripleAsterisks Inline+ TripleAsterisks}

Bold { !p2 DoubleAsterisks Inline+ DoubleAsterisks}

Italic { !p2 SingleAsterisk Inline+ SingleAsterisk}

Underline { !p2 Underscore Inline+ Underscore }

Note { !p2 NoteStart Inline+ NoteEnd}

Inline { !p2 Boneyard | Underline | ItalicBold | Bold | Italic | PlainText | Note | WhiteSpace }



// --- Tokens ---


@external tokens Fountain from "./tokenizer.js" {
  ForceActionMark,
  PageBreak,
  DualCharacter, 
  TitleKey,
  TitleValue
  Character,
  Transition,
  SynopsisMark,
  SceneHeading,
  GreaterThan,
  LessThan,
  BoneStart,
  BoneEnd,
  EmptyLine
}

@tokens {
  Newline { "\n" }
  Numbers { @digit }
  WhiteSpace { " "}
  LParen { "(" }
  RParen { ")" }
  NoteStart { "[[" }
  NoteEnd { "]]" }
  SectionMark {"#"}
  SingleAsterisk { "*" }
  DoubleAsterisks { "**" }
  TripleAsterisks { "***" }
  Underscore { "_"} 
  PlainText { ![()#<^*_\\/\]\[\n]+ }
  @precedence { GreaterThan LessThan NoteStart NoteEnd SectionMark LParen RParen BStart BEnd TripleAsterisks DoubleAsterisks SingleAsterisk Underscore WhiteSpace PlainText}
}



================================================================================
FILE: src/parser/fountain-parser.terms.js
================================================================================

// This file was generated by lezer-generator. You probably shouldn't edit it.
export const ForceActionMark = 1,
  PageBreak = 2,
  DualCharacter = 3,
  TitleKey = 4,
  TitleValue = 5,
  Character = 6,
  Transition = 7,
  SynopsisMark = 8,
  SceneHeading = 9,
  GreaterThan = 10,
  LessThan = 11,
  BoneStart = 12,
  BoneEnd = 13,
  EmptyLine = 14,
  Screenplay = 15,
  TitlePage = 16,
  Newline = 17,
  Boneyard = 18,
  Element = 19,
  ActionLine = 20,
  LineParenthetical = 21,
  LParen = 22,
  Inline = 23,
  Underline = 24,
  Underscore = 25,
  ItalicBold = 26,
  TripleAsterisks = 27,
  Bold = 28,
  DoubleAsterisks = 29,
  Italic = 30,
  SingleAsterisk = 31,
  PlainText = 32,
  Note = 33,
  NoteStart = 34,
  NoteEnd = 35,
  WhiteSpace = 36,
  RParen = 37,
  ForcedActionLine = 38,
  CenterLine = 39,
  ForceRight = 40,
  CharacterBlock = 41,
  CharacterCue = 42,
  DialogueLine = 43,
  Parenthetical = 44,
  DualCharacterBlock = 45,
  DualCharacterCue = 46,
  ForceTransition = 47,
  SceneHeadingLine = 48,
  SceneNumber = 49,
  SectionMark = 50,
  Numbers = 51,
  SectionLine = 52,
  SynopsisLine = 53,
  TransitionLine = 54,
  PageBreakLine = 55;


================================================================================
FILE: src/parser/fountain-parser.js
================================================================================

// This file was generated by lezer-generator. You probably shouldn't edit it.
import { LRParser } from '@lezer/lr';
import { Fountain } from './tokenizer.js';
export const parser = LRParser.deserialize({
  version: 14,
  states:
    ".WO!_OROOO!fOPO'#DfO!kOPO'#ClO!sORO'#CtO!sORO'#CvO!sORO'#CxO!sORO'#CzO!sORO'#C}O#_ORO'#CsOOOP'#Cs'#CsO!sORO'#CqOOOP'#Di'#DiO$rORO'#CpO$uORO'#DSO$uORO'#DUO$|ORO'#D]O%UOQO'#DWO%aOQO'#DVO%fOQO'#D[O%qOQO'#DZO%vORO'#D^OOOP'#Do'#DoO&TORO'#DbO$uORO'#DcO&bOQO'#DdO&gOQO'#DeOOOP'#Co'#CoO&lORO'#CnOOOP'#Dg'#DgQQOROOOQOROOO&sOQO,5:QOOOP-E7d-E7dO&xOPO,59WO'fORO,59`OOOP'#Dj'#DjO(UORO,59bO(tORO,59dO)dORO,59fO)kORO,59iO)rORO,59]OOOP-E7g-E7gOOOP,59[,59[O)yORO,59nO*TORO,59pO*bOQO,59oOOOP,59w,59wOOOO'#Dk'#DkO*gOQO,59rO*rORO,59qO*yOQO,59vO*rORO,59uOOOP'#Dm'#DmO+UORO,59xO+cOSO'#D_OOOP,59x,59xO+kOQO,59xO+pORO,59|OOOP-E7m-E7mOOOP,59|,59|O+zORO,59}OOOP,5:O,5:OOOOP,5:P,5:POOOP'#Dh'#DhO,UORO,59YOOOP,59Y,59YOOOP-E7e-E7eOOOP1G/l1G/lOOOP1G.r1G.rO,]ORO1G.zOOOP-E7h-E7hO-ZORO1G.|O.XORO1G/OO/VORO1G/QOOOP1G/T1G/TOOOP1G.w1G.wOOOP1G/Y1G/YOOOP1G/Z1G/ZOOOO-E7i-E7iO0TORO'#DXO!sORO'#DYO0[OQO'#DlO0aORO1G/]O1^ORO1G/aOOOP-E7k-E7kOOOP1G/d1G/dO2ZOQO1G/dOOOO'#Dn'#DnO2`OSO,59yOOOO,59y,59yOOOP1G/h1G/hOOOP1G/i1G/iOOOP-E7f-E7fOOOP1G.t1G.tO2hORO,59tOOOP,5:W,5:WOOOP-E7j-E7jOOOP7+%O7+%OOOOO-E7l-E7lOOOO1G/e1G/eOOOO1G/`1G/`",
  stateData:
    "2|~OP]OQiORbOU`OVhOWgOXdOY^O[kO^jOfYOiROkSOmTOoUOpXOrVOtXO!SeO~OSPO~PQOToO~OSPO^qO~O[kOiROkSOmTOoUOpXOrVOtXO~OP!ZXQ!ZXR!ZXU!ZXV!ZXW!ZXX!ZXY!ZX[gX^!ZXagXfgXigXkgXmgXogXpgXrgXtgX!S!ZX!d!ZX~OazOfYO~P!sOZ}Oa!OO~OfYOt!POazX~Oa!RO~OfYOt!POa!OX~Oa!TO~Oa!XOfYO!S!WO~P!sOa!]OfYO!SeO~P!sOa!_O~Oa!`O~O]!cO~PQOa!eO~O^!fO~O[kOkSOmTOoUOpXOrVOtXO~Oi!gO~P&}O[kOiROmTOoUOpXOrVOtXO~Ok!iO~P'mO[kOiROkSOoUOpXOrVOtXO~Om!jO~P(]O[kOiROkSOmTOpXOrVOtXO~Oo!kO~P({Os!lO~P!sOu!mO~P!sOa!nOfYO~P!sOfYOZxaaxa~P!sOa!oO~OfYOt!POaza~Of!rO~P!sOfYOt!POa!Oa~Oa!wOfYO!S!WO~P!sO!S!{O!T!yO~Oa!wO~Oa!|OfYO~P!sOa!}OfYO~P!sO]#PO~PQO[kOahifhiihikhimhiohiphirhithishiuhiZhi!Shi~O[kOajifjiijikjimjiojipjirjitjisjiujiZji!Sji~O[kOalifliiliklimlioliplirlitlisliuliZli!Sli~O[kOanifniiniknimnionipnirnitnisniuniZni!Sni~Oa{X~P!sOa#RO~Of!rOPyiQyiRyiUyiVyiWyiXyiYyi^yi!Syi!dyi]yi~P!sOf!rOP}iQ}iR}iU}iV}iW}iX}iY}i^}i!S}i!d}i]}i~P!sOa#TO~O!S#VO!T!yO~Ou#WO~P!sOrs!Sfukmoitpk~",
  goto: ")n!dPPPPPPPPPPPPPPPP!eP!h#e#n#uP$a%`P%`P%`P%`PP%`PPPP#n#n&V#n&^&e&e#n&k#n#n&rPP#n#n#n#n&x'O'V']'w(r(|)W)^)dRnOUWOmn!kXRSTUVY[]^dfgkrtuvwx{|!R!T!V!Z!^!b!g!i!j!k!q!r!t!u#QUlOmnT!ak!bZjOkmn!blZO[]^fgkmn{|!Z!^!bW!P`b!Q!ST!Ud!VlZO[]^fgkmn{|!Z!^!b!OsRSTUVYrtuvwx!R!T!g!i!j!k!q!r!t!u#QT!Ud!V!iXORSTUVY[]^dfgkmnrtuvwx{|!R!T!V!Z!^!b!q!r!t!u#QZ_Okmn!bZaOkmn!bX!s!R!T!t!uZcOkmn!bQ!YdR!x!VQQORpQSmOnR!dmQ!bkR#O!bY[Okmn!bYy[{|!Z!^Q{]Q|^Q!ZfR!^gSrR!gStS!iSuT!jSvU!kQwVQxY`!hrtuvwx!q#QW!q!R!T!t!uR#Q!rQ!Q`Q!SbT!p!Q!SQ!t!RQ!u!TT#S!t!uQ!VdR!v!VQ!z!WR#U!zYfOkmn!bR![f",
  nodeNames:
    '⚠ ForceActionMark PageBreak DualCharacter TitleKey TitleValue Character Transition SynopsisMark SceneHeading GreaterThan LessThan BoneStart BoneEnd EmptyLine Screenplay TitlePage Newline Boneyard Element ActionLine LineParenthetical LParen Inline Underline Underscore ItalicBold TripleAsterisks Bold DoubleAsterisks Italic SingleAsterisk PlainText Note NoteStart NoteEnd WhiteSpace RParen ForcedActionLine CenterLine ForceRight CharacterBlock CharacterCue DialogueLine Parenthetical DualCharacterBlock DualCharacterCue ForceTransition SceneHeadingLine SceneNumber SectionMark Numbers SectionLine SynopsisLine TransitionLine PageBreakLine',
  maxTerm: 66,
  skippedNodes: [0],
  repeatNodeCount: 10,
  tokenData:
    "&V~RdOY!aYZ#XZp!apq#^qs!ast$Qtx!axy$Vyz$[z{$a{!P!a!Q![$v![!^!a!_!}!a!}#O%j#P#Q%u#R#S&Q#S;'S!a;'S;=`#R<%lO!aP!fXpPOY!aZs!atx!a{!P!a!Q!^!a!_!}!a#S;'S!a;'S;=`#R<%lO!aP#UP;=`<%l!a~#^Oa~~#eXt~pPOY!aZs!atx!a{!P!a!Q!^!a!_!}!a#S;'S!a;'S;=`#R<%lO!a~$VO!S~~$[Of~~$aOu~~$fPo~z{$i~$nPm~z{$q~$vOk~R$}X!TQpPOY!aZs!atx!a{!P!a!Q!^!a!_!}!a#S;'S!a;'S;=`#R<%lO!a~%mP!}#O%p~%uOr~~%xP#P#Q%{~&QOs~~&VOi~",
  tokenizers: [Fountain, 0, 1],
  topRules: { Screenplay: [0, 15] },
  tokenPrec: 813,
});


================================================================================
FILE: src/parser/tokenizer.js
================================================================================

// src/parser/tokenizer.js

import { ExternalTokenizer } from '@lezer/lr';
import {
  PageBreak,
  TitleKey,
  TitleValue,
  Character,
  Transition,
  SynopsisMark,
  SceneHeading,
  GreaterThan,
  LessThan,
  BoneStart,
  BoneEnd,
  EmptyLine,
  DualCharacter,
  ForceActionMark, // This will be generated in the next step
} from './fountain-parser.terms.js';

// Character code constants (no changes here)
const newline = 10,
  space = 32,
  tab = 9,
  asterisk = 42,
  slash = 47,
  colon = 58,
  lParen = 40,
  rParen = 41,
  equals = 61,
  greaterThan = 62,
  lessThan = 60,
  at = 64,
  a = 97,
  z = 122,
  T = 84,
  O = 79,
  bang = 33,
  A = 65, // ADDED: Character code for 'A'
  Z = 90; // ADDED: Character code for 'Z'

class FountainTokenizer {
  constructor() {
    this.inBoneyard = false;
  }

  token(input, stack) {
    const start = input.pos;

    // --- Boneyard, TitleValue, LessThan, Start-of-line checks ---
    // (This top section of the code is unchanged)
    if (input.peek(0) === slash && input.peek(1) === asterisk) {
      if (!this.inBoneyard) {
        this.inBoneyard = true;
        input.advance(2);
        input.acceptToken(BoneStart);
        return;
      }
    }
    if (input.peek(0) === asterisk && input.peek(1) === slash) {
      if (this.inBoneyard) {
        this.inBoneyard = false;
        input.advance(2);
        input.acceptToken(BoneEnd);
        return;
      }
    }
    if (stack.canShift(TitleValue)) {
      let endPos = 0;
      while (input.peek(endPos) !== newline && input.peek(endPos) !== -1) {
        endPos++;
      }
      let lookahead = endPos;
      while (true) {
        if (input.peek(lookahead) === -1 || input.peek(lookahead) !== newline)
          break;
        let nextLineStart = lookahead + 1;
        const isTabIndented = input.peek(nextLineStart) === tab;
        const isSpaceIndented =
          input.peek(nextLineStart) === space &&
          input.peek(nextLineStart + 1) === space;
        if (isTabIndented || isSpaceIndented) {
          let nextLineEnd = nextLineStart;
          while (
            input.peek(nextLineEnd) !== newline &&
            input.peek(nextLineEnd) !== -1
          ) {
            nextLineEnd++;
          }
          endPos = nextLineEnd;
          lookahead = nextLineEnd;
        } else {
          break;
        }
      }
      input.advance(endPos);
      input.acceptToken(TitleValue);
      return;
    }
    if (input.peek(0) === lessThan) {
      let pos = 1;
      while (input.peek(pos) === space) pos++;
      const nextChar = input.peek(pos);
      if (nextChar === newline || nextChar === -1) {
        input.advance(1);
        input.acceptToken(LessThan);
        return;
      }
    }
    const isStartOfLine = start === 0 || input.peek(-1) === newline;
    if (!isStartOfLine) {
      return;
    }
    let scanPos = 0;
    while (true) {
      const char = input.peek(scanPos);
      if (char === space || char === tab) {
        scanPos++;
        continue;
      }
      if (char === newline) {
        input.advance(scanPos + 1);
        input.acceptToken(EmptyLine);
        return;
      }
      break;
    }
    if (input.peek(0) === greaterThan) {
      input.advance(1);
      input.acceptToken(GreaterThan);
      return;
    }
    if (input.peek(0) === equals && input.peek(1) !== equals) {
      input.advance(1);
      input.acceptToken(SynopsisMark);
      return;
    }
    if (
      input.peek(0) === equals &&
      input.peek(1) === equals &&
      input.peek(2) === equals
    ) {
      const nextChar = input.peek(3);
      if (nextChar === newline || nextChar === -1) {
        input.advance(3);
        input.acceptToken(PageBreak);
        return;
      }
    }
    let titleLineEndPos = start;
    let colonPos = -1;
    let hasContentBeforeColon = false;
    while (true) {
      const char = input.peek(titleLineEndPos - start);
      if (char === -1 || char === newline) break;
      if (char === colon) colonPos = titleLineEndPos;
      if (char !== space && colonPos === -1) hasContentBeforeColon = true;
      titleLineEndPos++;
    }
    if (colonPos !== -1 && hasContentBeforeColon && stack.canShift(TitleKey)) {
      input.advance(colonPos - start + 1);
      input.acceptToken(TitleKey);
      return;
    }
    const prefixes = ['INT./EXT.', 'INT/EXT.', 'INT.', 'EXT.', 'I/E.'];
    let buffer = '';
    for (let i = 0; i < 10; i++) {
      const char = input.peek(i);
      if (char === -1) break;
      buffer += String.fromCharCode(char);
    }
    for (const prefix of prefixes) {
      if (buffer.startsWith(prefix)) {
        input.advance(prefix.length);
        input.acceptToken(SceneHeading);
        return;
      }
    }
    if (input.peek(0) === 46 /* . */) {
      const nextChar = input.peek(1);
      if (
        nextChar !== 46 &&
        nextChar !== newline &&
        nextChar !== -1 &&
        nextChar !== space
      ) {
        input.advance(1);
        input.acceptToken(SceneHeading);
        return;
      }
    }

    // --- [REFACTORED] CHARACTER & TRANSITION LOGIC ---

    // MODIFIED: This is the new, more explicit implementation for the '!' rule.
    if (input.peek(0) === bang) {
      // This is a Forced Action Line. We consume the '!' as its own token
      // and let the grammar parse the rest of the line as the content.
      input.advance(1);
      input.acceptToken(ForceActionMark);
      return;
    }

    // Helper functions remain the same
    const isPrecededByBlankLine = () => {
      if (start === 0) return true;
      let prev = input.peek(-2);
      if (prev === 13) prev = input.peek(-3);
      return prev === newline;
    };
    const isFollowedByNonBlankLine = (endPos) => {
      let pos = endPos;
      if (input.peek(pos - start) === 13) pos++;
      if (input.peek(pos - start) === newline) pos++;
      while (input.peek(pos - start) === space) pos++;
      const nextChar = input.peek(pos - start);
      return nextChar !== newline && nextChar !== -1;
    };

    // The initial line scan remains the same
    let scanEndPos = start;
    let hasLowercase = false;
    let contentEndPos = start;
    let parenPos = -1;
    let lineLastChar = -1;
    let lineHasContent = false;
    while (true) {
      const char = input.peek(scanEndPos - start);
      if (char === -1 || char === newline) break;
      if (char >= a && char <= z) hasLowercase = true;
      if (char !== space) {
        contentEndPos = scanEndPos + 1;
        lineLastChar = char;
        lineHasContent = true;
      }
      if (char === lParen && parenPos === -1) parenPos = scanEndPos;
      scanEndPos++;
    }

    if (!lineHasContent) return;

    // The dual dialogue caret check remains the same
    let isDualDialogue = false;
    if (input.peek(contentEndPos - start - 1) === 94 /* ^ */) {
      isDualDialogue = true;
      contentEndPos--;
      while (
        contentEndPos > start &&
        input.peek(contentEndPos - start - 1) === space
      ) {
        contentEndPos--;
      }
      lineLastChar = input.peek(contentEndPos - start - 1);
    }

    // --- NEW LOGIC ORDER ---

    // Condition 1: Check for Forced Character (@) first, as it's the most specific override.
    if (input.peek(0) === at) {
      if (isPrecededByBlankLine() && isFollowedByNonBlankLine(scanEndPos)) {
        let characterNameEndPos = parenPos !== -1 ? parenPos : contentEndPos;
        while (
          characterNameEndPos > start &&
          input.peek(characterNameEndPos - start - 1) === space
        ) {
          characterNameEndPos--;
        }
        // A forced character cannot be a dual character.
        input.advance(characterNameEndPos - start);
        input.acceptToken(Character);
        return;
      }
    }

    // If the line has any lowercase letters, it can't be a Character or Transition, so we can exit.
    if (hasLowercase) {
      return;
    }

    // Condition 2: Check for a Transition.
    if (
      scanEndPos - start > 3 &&
      input.peek(contentEndPos - start - 3) === T &&
      input.peek(contentEndPos - start - 2) === O &&
      input.peek(contentEndPos - start - 1) === colon
    ) {
      input.advance(scanEndPos - start);
      input.acceptToken(Transition);
      return;
    }

    // MODIFIED: Condition 3: Handle Regular and Dual Characters with the new, more specific rule.
    const firstChar = input.peek(0);
    const secondChar = input.peek(1);
    const startsWithTwoCaps =
      firstChar >= A && firstChar <= Z && secondChar >= A && secondChar <= Z;

    if (
      startsWithTwoCaps &&
      isPrecededByBlankLine() &&
      isFollowedByNonBlankLine(scanEndPos)
    ) {
      const extensionIsValid =
        parenPos === -1 || (parenPos !== -1 && lineLastChar === rParen);

      if (extensionIsValid) {
        let characterNameEndPos = parenPos !== -1 ? parenPos : contentEndPos;
        while (
          characterNameEndPos > start &&
          input.peek(characterNameEndPos - start - 1) === space
        ) {
          characterNameEndPos--;
        }

        if (isDualDialogue) {
          input.advance(characterNameEndPos - start);
          input.acceptToken(DualCharacter);
        } else {
          input.advance(characterNameEndPos - start);
          input.acceptToken(Character);
        }
        return;
      }
    }
  }
}

const tokenizer = new FountainTokenizer();
export const Fountain = new ExternalTokenizer(tokenizer.token.bind(tokenizer));


================================================================================
FILE: src/hooks/useYjsPersistence.ts
================================================================================

import { useState, useCallback, useRef } from 'react'
import * as Y from 'yjs'
import { SupabaseClient } from '@supabase/supabase-js'
import debounce from 'lodash/debounce'

type SaveStatus = 'idle' | 'loading' | 'saving' | 'saved' | 'error'

export const useYjsPersistence = (supabase: SupabaseClient, doc: Y.Doc) => {
  const [status, setStatus] = useState<SaveStatus>('idle')
  const isLoaded = useRef(false)
  
  // Parse Postgres HEX format (\x0123...)
  const parsePostgresHex = (hexContent: string): Uint8Array => {
    // Handle bytea format
    const cleanHex = hexContent.startsWith('\\x') ? hexContent.slice(2) : hexContent
    if (!/^[0-9a-fA-F]*$/.test(cleanHex)) return new Uint8Array([])
    const match = cleanHex.match(/.{1,2}/g)
    if (!match) return new Uint8Array([])
    return new Uint8Array(match.map((byte) => parseInt(byte, 16)))
  }

  const loadDocument = useCallback(async (documentId: string) => {
    setStatus('loading')
    isLoaded.current = false // Reset loaded state
    try {
      const { data, error } = await supabase
        .from('documents')
        .select('content')
        .eq('id', documentId)
        .maybeSingle()

      if (error) throw error

      if (data?.content) {
        // Handle both string format (from DB) or potential raw bytes
        const contentStr = typeof data.content === 'string' ? data.content : ''
        const update = parsePostgresHex(contentStr)
        
        if (update.length > 0) {
          Y.applyUpdate(doc, update, 'db-load')
        }
      }
      isLoaded.current = true
      setStatus('saved')
    } catch (e) {
      console.error('Failed to load document:', e)
      setStatus('error')
    }
  }, [supabase, doc])

  const saveDocument = useCallback(
    debounce(async (documentId: string) => {
      if (!isLoaded.current) return 

      setStatus('saving')
      try {
        const state = Y.encodeStateAsUpdate(doc)
        
        // Convert to HEX for Postgres bytea
        const hex = Array.from(state)
          .map((b) => b.toString(16).padStart(2, '0'))
          .join('')
        
        // We only update content and timestamp
        const { error } = await supabase
          .from('documents')
          .update({ 
            content: `\\x${hex}`,
            updated_at: new Date().toISOString()
          })
          .eq('id', documentId)

        if (error) throw error
        
        setStatus('saved')
      } catch (e) {
        console.error('Failed to save document:', e)
        setStatus('error')
      }
    }, 2000), 
    [supabase, doc]
  )

  return { status, loadDocument, saveDocument }
}
